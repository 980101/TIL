### 오늘 한 일
- BOJ 1715 풀이 시도 ...

### 오늘 배운 것
#### 얕은 복사
: 객체의 참조만 복사함

<br>

🔍 공부한 코드
```
let obj1 = {
  x : 1,
  y : {
        z : 100
      }
}

let obj2 = {...obj1};

// x 변경 (원시값)
obj2.x = 999;

// y.z 변경 (객체 내부 값)
obj2.y.z = 555;

console.log("obj1.x: ", obj1.x);  // 1 (영향 없음)
console.log("obj2.x: ", obj2.x);  // 999 (영향 없음)

console.log("obj1.y.z: ", obj1.y.z);  // 555 (같이 바뀜)
console.log("obj2.y.z: ", obj2.y.z);  // 555
```

- obj2가 생성되면서 새로운 객체가 만들어 지고, obj1의 내용이 복사됨
  - x key는 원시값을 가지기 때문에 값 자체가 변경됨
  - y key는 해시 테이블의 특정 공간을 가리키기 때문에 **해당 공간에 저장된 값이 바뀜**
    👉 그래서 obj1과 obj2 둘 다 값이 변경 !

- 추가 정보
  - 원시값 (primitive type) : 값 자체로 존재하는 데이터. 복사하거나 비교할 때 값 자체가 복사/비교됨
  - 전개 연산자 : 객체나 배열을 펼칠 때 사용함
  ```
  const arr1 = [1, 2, 3];
  const arr2 = [...arr1, 4, 5];  // arr1을 펼쳐서 새로운 배열 만듦
  console.log(arr2); // [1, 2, 3, 4, 5]
  ```
---


  #### 깊은 복사
  : 객체의 값 자체를 복사함 👉 JS에서는 structuredClone() 메서드를 사용하면 속도가 빠름
```
const original = {
          user: "Alice",
          settings: {
            theme: "dark"
          }
};

const copy = structuredClone(original);
copy.settings.theme = "light";

console.log(original.settings.theme); // "dark"
```
