### 오늘 한 일
### 오늘 배운 것
* 모든 클래스는 Object 클래스의 자식이다. </br> ➡️ Object 클래스가 클래스 계층 구조의 최상위(superclass)이기 때문

___
  
* 멤버 (필드, 메서드)
  * 멤버는 인스턴스, static으로 구분된다.
 
  * 인스턴스 멤버 (Instance Member) : 객체가 생성될 때마다 따로 생기는 멤버
      - 객체가 각각 다른 값을 가질 수 있다.
      - 반드시 객체를 생성하고 접근해야 한다.
  * static 멤버 : 클래스에 소속된 멤버.
      - static 키워드로 선언
      - 객체들이 같은 값을 가진다. = 모든 객체가 공유한다.
      - 객체 없이도 접근 가능하다.
   
```java
public class MemberTest {
    // 인스턴스 멤버 (객체마다 따로 있음)
    int instanceCount = 0;

    // static 멤버 (모든 객체가 공유)
    static int staticCount = 0;

    public void increase() {
        instanceCount++;
        staticCount++;
    }
}
```

___
     
* 멤버변수는 자동 초기화 가능하지만 지역변수는 직접 초기화해줘야 한다.

| 항목     | 멤버 변수 (필드)    | 지역 변수       |
| ------ | ------------- | ----------- |
| 선언 위치  | 클래스 내부        | 메서드 내부      |
| 초기화 여부 | 자동으로 기본값 설정   | ❌ 수동 초기화 필요 |
| 메모리 영역 | 힙 영역 / 클래스 영역 | 스택 영역       |
| 생성 시점  | 객체 생성 시점      | 메서드 실행 시점   |

  * 왜 스택(지역 변수)은 자동 초기화 안 될까?
  : 성능 때문.
    - 스택은 빠르게 만들어지고 사라져야 하는 임시 공간이다. </br>그래서 초기화를 JVM이 알아서 하지 않고, 개발자에게 맡깁니다. </br>초기화하지 않고 사용하면 → 컴파일 에러 발생 ➡️ 개발자 실수 방지

  * 왜 힙(멤버 변수)은 자동 초기화될까?
  : 힙은 new로 만든 객체 저장 공간이고, 자바에서는 객체를 만들 때 기본값으로 초기화하는 것이 안정성에 중요하다. </br> 그래서 int는 0, boolean은 false, 객체는 null로 자동 설정된다.


___

* Java에서 음수를 처리하는 방법 : 2의 보수 방식
  * 계산 방식
  1. 10진수 값을 2진수로 바꾼다.
  2. 0을 1로, 1을 0으로 변경한다. = 1의 보수 방식
  3. 1을 더한다.

  * 비트 값이 음수인지 양수인지 알 수 있는 방법은 없다. 해석을 어떤 식으로 할지 정해야 알 수 있다. </br>예를 들어 10001001은 137이 될 수도 있고, -119가 될 수도 있다.

  * -5를 2의 보수로 표현하는 단계
    
| 단계 | 설명                          | 결과       |
|------|-------------------------------|------------|
| ①    | **+5를 2진수로 표현**           | `00000101` |
| ②    | **1의 보수 (0↔1 반전)**        | `11111010` |
| ③    | **2의 보수 (1 더하기)**         | `11111011` ← 최종 결과! |


___

* 쉬프트연산자에서 >>와 >>>의 차이
  
| 항목       | `>>` (산술 우쉬프트) | `>>>` (논리 우쉬프트) |
| -------- | -------------- | --------------- |
| 음수 처리    | 부호(1)를 유지      | 부호 무시, 무조건 0 채움 |
| 부호 비트 유지 | ✅ 유지함          | ❌ 유지 안 함        |
| 결과 부호    | 유지될 수 있음       | 항상 양수로 변할 수 있음  |

```
  원래 값  : 11111000   (-8)
  >> 2 한 결과: 11111110   (-2)
  >>> 2 한 결과: 00111110   (+62)
```

___

* 논리연산자와 비트연산자 차이
  * 논리연산자는 short-circuit으로 왼쪽 조건으로 결과가 확정되면 오른쪽은 판단하지 않는다.
  * 비트연산자는 무조건 양쪽 모두 연산한다.
 ```java
public static void main(String[] args) {
        int num = 6;

        // "condition2 check!" 출력됨.
        if (num == 9 & isEven(num)) {
          System.out.println("This is 9");
        }

        // "condition2 check!" 출력 안됨.
        if (num == 9 && isEven(num)) {
          System.out.println("This is 9");
        }

        static boolean isEven(int num) {
          System.out.println("condition2 check!");
        }
```
